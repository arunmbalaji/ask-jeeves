{"version":3,"sources":["User.js"],"names":["async","let","dfd","Deferred","server","http","createServer","req","res","method","url","body","on","data","resolve","qs","parse","writeHead","end","err","socket","connections","conn","key","remoteAddress","remotePort","destroy","cb","close","port","await","freeportAsync","listen","callbackURL","getTokenInfoAsync","promise","_startLoginServerAsync","AUTH0_DOMAIN","AUTHENTICATION_SERVER_TIMEOUT","UserManagerInstance","clientID","loginServer","refreshSessionThreshold","_currentUser","_getSessionLock","static","getGlobalInstance","__globalInstance","initialize","loginAsync","loginType","loginArgs","loginOptions","Error","apiAnonymous","ApiV2Client","clientForUser","loginResp","postAsync","username","password","clientId","testSession","error","ErrorCode","INVALID_USERNAME_PASSWORD","_getProfileAsync","currentConnection","accessToken","access_token","refreshToken","refresh_token","idToken","id_token","refreshTokenClientId","sessionSecret","connection","scope","responseMode","responseType","device","auth0Options","destroyServerTimer","setTimeout","listening","redirectUri","_auth0SocialLogin","tokenInfo","clearTimeout","profile","registerAsync","userData","user","getCurrentUserAsync","logoutAsync","currentUser","registeredUser","createOrUpdateUserAsync","email","userMetadata","onboarded","givenName","familyName","e","console","REGISTRATION_ERROR","message","migrateAuth0ToSessionAsync","options","testMode","hasCachedSession","UserSettings","getAsync","api","response","mergeAsync","auth","ensureLoggedInAsync","Config","offline","NOT_LOGGED_IN","acquire","_isTokenExpired","Logger","global","code","release","updatedUser","_prepareAuth0Profile","_parseAuth0Profile","kind","details","Analytics","logEvent","deleteKeyAsync","Intercom","update","forgotPasswordAsync","usernameOrEmail","dtoken","jwt","decode","complete","aud","payload","currentRefreshTokenClientId","dateAuth0Gone","Date","now","delegationResult","_auth0RefreshToken","userId","setUserProperties","intercomUserHash","exp","process","env","NODE_ENV","debug","isNode","opn","_buildAuth0SocialLoginUrl","wait","webAuth","_auth0WebAuthInstanceWithOptions","authorize","delegationTokenOptions","api_type","target","client_id","grant_type","window","delegationAsync","promisify","client","delegation","bind","Auth0Node","_nodeAuth0InstanceWithOptions","tokens","getDelegationToken","_formatAuth0NodeError","errData","TOO_MANY_ATTEMPTS","error_description","qsData","response_type","response_mode","redirect_uri","queryString","stringify","auth0","require","domain","_disableDeprecationWarnings","WebAuth","Auth0Instance","management","_","omit","ManagementClient","AuthenticationClient","rawProfile","Object","keys","reduce","p","camelCase","niceProfile","snakeCase","constructor","Promise","reject"],"mappings":"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","file":"../User.js","sourcesContent":["/**\n * @flow\n */\n\nimport _ from 'lodash';\nimport freeportAsync from 'freeport-async';\nimport http from 'http';\nimport qs from 'querystring';\nimport opn from 'opn';\nimport jwt from 'jsonwebtoken';\nimport promisify from 'util.promisify';\n\nimport type { WebAuth } from 'auth0-js';\nimport type Auth0Node from 'auth0';\n\nimport ApiV2Client, { ApiV2Error } from './ApiV2';\n\nimport * as Analytics from './Analytics';\nimport Config from './Config';\nimport ErrorCode from './ErrorCode';\nimport XDLError from './XDLError';\nimport Logger from './Logger';\n\nimport * as Intercom from './Intercom';\nimport UserSettings from './UserSettings';\n\nimport { Semaphore } from './Utils';\nimport { isNode } from './tools/EnvironmentHelper';\n\nexport type User = {\n  kind: 'user',\n  // required\n  name: string,\n  username: string,\n  nickname: string,\n  userId: string,\n  picture: string,\n  // optional\n  email?: string,\n  emailVerified?: boolean,\n  givenName?: string,\n  familyName?: string,\n  loginsCount?: number,\n  intercomUserHash: string,\n  userMetadata: {\n    onboarded: boolean,\n    legacy?: boolean,\n  },\n  identities: Array<{\n    connection: ConnectionType,\n    isSocial: boolean,\n    provider: string,\n    userId: string,\n  }>,\n  accessToken: string,\n  idToken: string,\n  refreshToken: string,\n  currentConnection: ConnectionType,\n  sessionSecret: string,\n};\n\nexport type LegacyUser = {\n  kind: 'legacyUser',\n  username: string,\n  userMetadata: {\n    legacy: boolean,\n    needsPasswordMigration: boolean,\n  },\n};\n\nexport type UserOrLegacyUser = User | LegacyUser;\n\ntype ConnectionType = 'Username-Password-Authentication' | 'facebook' | 'google-oauth2' | 'github';\n\ntype LoginOptions = {\n  connection: ConnectionType,\n  device: string,\n  responseType: string,\n  responseMode: string,\n  username?: string,\n  password?: string,\n};\n\nexport type RegistrationData = {\n  username: string,\n  password: string,\n  email?: string,\n  givenName?: string,\n  familyName?: string,\n};\n\ntype Auth0Options = {\n  clientID: string,\n  redirectUri?: string,\n};\n\nexport type LoginType = 'user-pass' | 'facebook' | 'google' | 'github';\n\nconst AUTH0_DOMAIN = 'exponent.auth0.com';\nconst AUTHENTICATION_SERVER_TIMEOUT = 1000 * 60 * 5; // 5 minutes\n\nexport class UserManagerInstance {\n  clientID = 'o0YygTgKhOTdoWj10Yl9nY2P0SMTw38Y'; // Default Client ID\n  loginServer = null;\n  refreshSessionThreshold = 60 * 60; // 1 hour\n  _currentUser: ?User = null;\n  _getSessionLock = new Semaphore();\n\n  static getGlobalInstance() {\n    if (!__globalInstance) {\n      __globalInstance = new UserManagerInstance();\n    }\n    return __globalInstance;\n  }\n\n  initialize(clientID: ?string) {\n    if (clientID) {\n      this.clientID = clientID;\n    }\n    this.loginServer = null;\n    this._currentUser = null;\n    this._getSessionLock = new Semaphore();\n  }\n\n  /**\n   * Logs in a user for a given login type.\n   *\n   * Valid login types are:\n   *  - \"user-pass\": Username and password authentication\n   *  - \"facebook\": Facebook authentication\n   *  - \"google\": Google authentication\n   *  - \"github\": Github authentication\n   *\n   * If the login type is \"user-pass\", we directly make the request to Auth0\n   * to login a user.\n   *\n   * If the login type is any of the social providers, we start a web server\n   * that can act as the receiver of the OAuth callback from the authentication\n   * process. The response we receive on that web server will be token data.\n   */\n  async loginAsync(\n    loginType: LoginType,\n    loginArgs?: { username: string, password: string, testSession?: boolean }\n  ): Promise<User> {\n    let loginOptions;\n\n    if (loginType === 'user-pass') {\n      if (!loginArgs) {\n        throw new Error(`The 'user-pass' login type requires a username and password.`);\n      }\n      const apiAnonymous = ApiV2Client.clientForUser();\n      const loginResp = await apiAnonymous.postAsync('auth/loginAsync', {\n        username: loginArgs.username,\n        password: loginArgs.password,\n        clientId: this.clientID,\n        ...(loginArgs.testSession ? { testSession: loginArgs.testSession } : {}),\n      });\n      if (loginResp.error) {\n        throw new XDLError(ErrorCode.INVALID_USERNAME_PASSWORD, loginResp['error_description']);\n      }\n      return this._getProfileAsync({\n        currentConnection: 'Username-Password-Authentication',\n        accessToken: loginResp.access_token,\n        refreshToken: loginResp.refresh_token,\n        idToken: loginResp.id_token,\n        refreshTokenClientId: this.clientID,\n        sessionSecret: loginResp.sessionSecret,\n      });\n    } else if (loginType === 'facebook') {\n      loginOptions = {\n        connection: 'facebook',\n      };\n    } else if (loginType === 'google') {\n      loginOptions = {\n        connection: 'google-oauth2',\n      };\n    } else if (loginType === 'github') {\n      loginOptions = {\n        connection: 'github',\n      };\n    } else {\n      throw new Error(\n        `Invalid login type provided. Must be one of 'user-pass', 'facebook', 'google', or 'github'.`\n      );\n    }\n\n    loginOptions = {\n      ...loginOptions,\n      scope: 'openid offline_access username nickname',\n      // audience: 'https://exp.host',\n      responseMode: 'form_post',\n      responseType: 'token',\n      device: 'xdl',\n    };\n\n    let auth0Options = {\n      clientID: this.clientID,\n    };\n\n    // Doing a social login, so start a server\n    const { server, callbackURL, getTokenInfoAsync } = await _startLoginServerAsync();\n\n    // Kill server after 5 minutes if it hasn't already been closed\n    const destroyServerTimer = setTimeout(() => {\n      if (server.listening) {\n        server.destroy();\n      }\n    }, AUTHENTICATION_SERVER_TIMEOUT);\n\n    auth0Options = {\n      clientID: this.clientID,\n      redirectUri: callbackURL,\n    };\n\n    // Don't await -- we'll get response back through server\n    // This will open a browser window\n    this._auth0SocialLogin(auth0Options, loginOptions);\n\n    // Wait for token info to come back from server\n    const tokenInfo = await getTokenInfoAsync();\n\n    server.destroy();\n    clearTimeout(destroyServerTimer);\n\n    const profile = await this._getProfileAsync({\n      currentConnection: loginOptions.connection,\n      accessToken: tokenInfo.access_token,\n      refreshToken: tokenInfo.refresh_token,\n      idToken: tokenInfo.id_token,\n      refreshTokenClientId: this.clientID,\n    });\n\n    return profile;\n  }\n\n  async registerAsync(userData: RegistrationData, user: ?UserOrLegacyUser): Promise<User> {\n    if (!user) {\n      user = await this.getCurrentUserAsync();\n    }\n\n    if (user) {\n      await this.logoutAsync();\n      user = null;\n    }\n\n    const currentUser: ?User = (user: any);\n\n    try {\n      // Create or update the profile\n      let registeredUser = await this.createOrUpdateUserAsync({\n        connection: 'Username-Password-Authentication', // Always create/update username password\n        email: userData.email,\n        userMetadata: {\n          onboarded: true,\n          givenName: userData.givenName,\n          familyName: userData.familyName,\n        },\n        username: userData.username,\n        password: userData.password,\n      });\n\n      registeredUser = await this.loginAsync('user-pass', {\n        username: userData.username,\n        password: userData.password,\n      });\n\n      return registeredUser;\n    } catch (e) {\n      console.error(e);\n      throw new XDLError(ErrorCode.REGISTRATION_ERROR, 'Error registering user: ' + e.message);\n    }\n  }\n\n  /**\n   * Migrate a user from auth0 tokens to sessions\n   * TODO: remove when everyone is migrated to sessions\n   */\n  async migrateAuth0ToSessionAsync(options: { [string]: any } = { testMode: false }) {\n    const { testMode } = options;\n    // If logged in but using legacy auth0 tokens, migrate to sessions\n    const user = await this.getCurrentUserAsync();\n    if (!user) {\n      return;\n    }\n    const hasCachedSession = this._currentUser && this._currentUser.sessionSecret;\n    if (hasCachedSession) {\n      return;\n    }\n\n    // check for sessionSecret in state.json file\n    let sessionSecret = await UserSettings.getAsync('auth.sessionSecret', null);\n    if (sessionSecret) {\n      return;\n    }\n    let api = ApiV2Client.clientForUser({\n      idToken: user.idToken,\n      accessToken: user.accessToken,\n    });\n\n    try {\n      // get sessionSecret and save it\n      const response = await api.postAsync('auth/auth0ToSession', {\n        ...(testMode ? { testSession: testMode } : {}),\n      });\n      const { sessionSecret } = response;\n      if (sessionSecret) {\n        user.sessionSecret = sessionSecret;\n        await UserSettings.mergeAsync({\n          auth: {\n            sessionSecret,\n          },\n        });\n      }\n      return response;\n    } catch (e) {}\n  }\n\n  /**\n   * Ensure user is logged in and has a valid token.\n   *\n   * If there are any issues with the login, this method throws.\n   */\n  async ensureLoggedInAsync(): Promise<?User> {\n    if (Config.offline) {\n      return null;\n    }\n\n    // migrate from auth0 to sessions, if available\n    await this.migrateAuth0ToSessionAsync();\n\n    const user = await this.getCurrentUserAsync();\n    if (!user) {\n      throw new XDLError(ErrorCode.NOT_LOGGED_IN, 'Not logged in');\n    }\n    return user;\n  }\n\n  /**\n   * Get the current user based on the available token.\n   * If there is no current token, returns null.\n   */\n  async getCurrentUserAsync(): Promise<?User> {\n    await this._getSessionLock.acquire();\n\n    try {\n      // If user is cached and there is a sessionSecret, or the Auth0 token isn't expired\n      // return the user\n      if (this._currentUser) {\n        if (this._currentUser.sessionSecret || !this._isTokenExpired(this._currentUser.idToken)) {\n          return this._currentUser;\n        }\n      }\n\n      if (Config.offline) {\n        return null;\n      }\n\n      // Not cached, check for token\n      let {\n        currentConnection,\n        idToken,\n        accessToken,\n        refreshToken,\n        sessionSecret,\n      } = await UserSettings.getAsync('auth', {});\n\n      // No tokens/session, no current user. Need to login\n      if ((!currentConnection || !idToken || !accessToken || !refreshToken) && !sessionSecret) {\n        return null;\n      }\n\n      try {\n        return await this._getProfileAsync({\n          currentConnection,\n          accessToken,\n          idToken,\n          refreshToken,\n          sessionSecret,\n        });\n      } catch (e) {\n        Logger.global.error(e);\n        // Surface network errors\n        if (e.code === 'ECONNREFUSED' || e.code === 'ENOTFOUND' || e.code === 'ETIMEDOUT') {\n          throw new Error(\n            'Could not connect to the server. Please check your internet connection.'\n          );\n        }\n        // This logs us out if theres a fatal error when getting the profile with\n        // current access token\n        await this.logoutAsync();\n        return null;\n      }\n    } finally {\n      this._getSessionLock.release();\n    }\n  }\n\n  /**\n   * Create or update a user.\n   */\n  async createOrUpdateUserAsync(userData: Object): Promise<User> {\n    let currentUser = this._currentUser;\n    if (!currentUser) {\n      // attempt to get the current user\n      currentUser = await this.getCurrentUserAsync();\n    }\n\n    try {\n      const api = ApiV2Client.clientForUser(this._currentUser);\n\n      const { user: updatedUser } = await api.postAsync('auth/createOrUpdateUser', {\n        userData: _prepareAuth0Profile(userData),\n      });\n\n      this._currentUser = {\n        ...(this._currentUser || {}),\n        ..._parseAuth0Profile(updatedUser),\n      };\n      return {\n        kind: 'user',\n        ...this._currentUser,\n      };\n    } catch (e) {\n      const err: ApiV2Error = (e: any);\n      if (err.code === 'AUTHENTICATION_ERROR') {\n        throw new Error(err.details.message);\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * Logout\n   */\n  async logoutAsync(): Promise<void> {\n    if (this._currentUser) {\n      Analytics.logEvent('Logout', {\n        username: this._currentUser.username,\n      });\n    }\n\n    this._currentUser = null;\n\n    // Delete saved JWT\n    await UserSettings.deleteKeyAsync('auth');\n\n    // Logout of Intercom\n    Intercom.update(null);\n  }\n\n  /**\n   * Forgot Password\n   */\n  async forgotPasswordAsync(usernameOrEmail: string): Promise<void> {\n    const apiAnonymous = ApiV2Client.clientForUser();\n    return apiAnonymous.postAsync('auth/forgotPasswordAsync', {\n      usernameOrEmail,\n      clientId: this.clientID,\n    });\n  }\n\n  /**\n   * Get profile given token data. Errors if token is not valid or if no\n   * user profile is returned.\n   *\n   * This method is called by all public authentication methods of `UserManager`\n   * except `logoutAsync`. Therefore, we use this method as a way to:\n   *  - update the UserSettings store with the current token and user id\n   *  - update UserManager._currentUser\n   *  - Fire login analytics events\n   *  - Update the currently assigned Intercom user\n   *\n   * Also updates UserManager._currentUser.\n   *\n   * @private\n   */\n  async _getProfileAsync({\n    currentConnection,\n    accessToken,\n    idToken,\n    refreshToken,\n    refreshTokenClientId,\n    sessionSecret,\n  }: {\n    currentConnection: ConnectionType,\n    accessToken?: string,\n    idToken?: string,\n    refreshToken?: string,\n    refreshTokenClientId?: string,\n    sessionSecret?: string,\n  }): Promise<User> {\n    let user;\n    if (!sessionSecret) {\n      // Attempt to grab profile from Auth0.\n      // If token is expired / getting the profile fails, use refresh token to\n      try {\n        const dtoken = jwt.decode(idToken, { complete: true });\n        const { aud } = dtoken.payload;\n\n        // If it's not a new login, refreshTokenClientId won't be set in the arguments.\n        // In this case, try to get the currentRefreshTokenClientId from UserSettings,\n        // otherwise, default back to the audience of the current id_token\n        if (!refreshTokenClientId) {\n          const { refreshTokenClientId: currentRefreshTokenClientId } = await UserSettings.getAsync(\n            'auth',\n            {}\n          );\n          if (!currentRefreshTokenClientId) {\n            refreshTokenClientId = aud; // set it to the \"aud\" property of the existing token\n          } else {\n            refreshTokenClientId = currentRefreshTokenClientId;\n          }\n        }\n        if (this._isTokenExpired(idToken)) {\n          // User has expired token and no session -- they need to log back in if Auth0 is gone\n          const dateAuth0Gone = new Date(2018, 3, 2); // April 1, 2018 - the months are 0 indexed\n          if (Date.now() > dateAuth0Gone) {\n            await this.logoutAsync();\n            throw new XDLError('Tokens expired, logging out. Please try again.');\n          }\n          const delegationResult = await this._auth0RefreshToken(\n            refreshTokenClientId, // client id that's associated with the refresh token\n            refreshToken // refresh token to use\n          );\n          idToken = delegationResult.id_token;\n        }\n      } catch (e) {\n        throw e;\n      }\n    }\n\n    let api = ApiV2Client.clientForUser({\n      idToken,\n      accessToken,\n      sessionSecret,\n    });\n\n    user = await api.postAsync('auth/userProfileAsync', { clientId: this.clientID });\n\n    if (!user) {\n      throw new Error('Unable to fetch user.');\n    }\n\n    user = {\n      ..._parseAuth0Profile(user),\n      kind: 'user',\n      currentConnection,\n      ...(accessToken ? { accessToken } : {}),\n      ...(idToken ? { idToken } : {}),\n      ...(refreshToken ? { refreshToken } : {}),\n      ...(sessionSecret ? { sessionSecret } : {}),\n    };\n\n    await UserSettings.mergeAsync({\n      auth: {\n        userId: user.userId,\n        username: user.username,\n        currentConnection,\n        ...(accessToken ? { accessToken } : {}),\n        ...(idToken ? { idToken } : {}),\n        ...(refreshToken ? { refreshToken } : {}),\n        ...(refreshTokenClientId ? { refreshTokenClientId } : {}),\n        ...(sessionSecret ? { sessionSecret } : {}),\n      },\n    });\n\n    // If no currentUser, or currentUser.id differs from profiles\n    // user id, that means we have a new login\n    if (\n      (!this._currentUser || this._currentUser.userId !== user.userId) &&\n      user.username &&\n      user.username !== ''\n    ) {\n      Analytics.logEvent('Login', {\n        userId: user.userId,\n        currentConnection: user.currentConnection,\n        username: user.username,\n      });\n\n      Analytics.setUserProperties(user.username, {\n        userId: user.userId,\n        currentConnection: user.currentConnection,\n        username: user.username,\n      });\n\n      if (user.intercomUserHash) {\n        Intercom.update(user);\n      }\n    } else {\n      Intercom.update(null);\n    }\n\n    this._currentUser = user;\n\n    return user;\n  }\n\n  _isTokenExpired(idToken: string): boolean {\n    const dtoken = jwt.decode(idToken, { complete: true });\n    const { exp } = dtoken.payload;\n    // TODO(@skevy): remove\n    if (process.env.NODE_ENV !== 'production') {\n      Logger.global.debug('TOKEN EXPIRATION', exp);\n    }\n    // TODO(@skevy): remove\n    if (process.env.NODE_ENV !== 'production') {\n      Logger.global.debug('TOKEN TIME LEFT', exp - Date.now() / 1000);\n    }\n\n    return exp - Date.now() / 1000 <= this.refreshSessionThreshold;\n  }\n\n  _auth0SocialLogin(auth0Options: Auth0Options, loginOptions: LoginOptions) {\n    if (isNode()) {\n      opn(_buildAuth0SocialLoginUrl(auth0Options, loginOptions), {\n        wait: false,\n      });\n    } else {\n      const webAuth = _auth0WebAuthInstanceWithOptions(auth0Options);\n      webAuth.authorize(loginOptions);\n    }\n  }\n\n  async _auth0RefreshToken(clientId: string, refreshToken: string): Promise<*> {\n    const delegationTokenOptions = {\n      refresh_token: refreshToken,\n      api_type: 'app',\n      scope: 'openid offline_access nickname username',\n      target: this.clientID,\n      client_id: clientId,\n      grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n    };\n\n    if (typeof window !== 'undefined' && window) {\n      const webAuth = _auth0WebAuthInstanceWithOptions({ clientID: clientId });\n      const delegationAsync = promisify(webAuth.client.delegation.bind(webAuth.client));\n      return await delegationAsync(delegationTokenOptions);\n    }\n\n    const Auth0Node = _nodeAuth0InstanceWithOptions({\n      clientID: this.clientID,\n    });\n\n    const delegationResult = await Auth0Node.tokens.getDelegationToken(delegationTokenOptions);\n\n    return delegationResult;\n  }\n}\n\nlet __globalInstance;\nexport default UserManagerInstance.getGlobalInstance();\n\n/** Private Methods **/\n\ntype APIError = Error & {\n  name: string,\n  statusCode: string,\n};\n\ntype ErrorWithDescription = Error & {\n  description?: string,\n};\n\nfunction _formatAuth0NodeError(e: APIError) {\n  // TODO: Fix the Auth0 js library to throw better error messages when the network fails.\n  // Auth0 returns an error object whenver Auth0 fails to make an API request.\n  // These error messages are usually well-formed when you have an invalid login or too many attempts,\n  // but when the network is down it does not give any meaningful messages.\n  // Network failures log the user out in _getCurrentUserAsync() when it uses Auth0.\n  const errData = e.message;\n  switch (errData.error) {\n    case 'invalid_user_password':\n      return new XDLError(ErrorCode.INVALID_USERNAME_PASSWORD, 'Invalid username or password');\n    case 'too_many_attempts':\n      return new XDLError(ErrorCode.TOO_MANY_ATTEMPTS, errData.error_description);\n    default:\n      return new Error(errData.error_description);\n  }\n  return e;\n}\n\nfunction _buildAuth0SocialLoginUrl(auth0Options: Auth0Options, loginOptions: LoginOptions) {\n  const qsData = {\n    scope: 'openid offline_access username nickname',\n    response_type: loginOptions.responseType,\n    response_mode: loginOptions.responseMode,\n    connection: loginOptions.connection,\n    device: 'xdl',\n    client_id: auth0Options.clientID,\n    redirect_uri: auth0Options.redirectUri,\n  };\n\n  const queryString = qs.stringify(qsData);\n\n  return `https://${AUTH0_DOMAIN}/authorize?${queryString}`;\n}\n\nfunction _auth0WebAuthInstanceWithOptions(options: Auth0Options): WebAuth {\n  const auth0 = require('auth0-js');\n\n  let auth0Options = {\n    domain: AUTH0_DOMAIN,\n    responseType: 'token',\n    _disableDeprecationWarnings: true,\n    ...options,\n  };\n\n  return new auth0.WebAuth(auth0Options);\n}\n\nfunction _nodeAuth0InstanceWithOptions(options: Object = {}): any {\n  let auth0Options = {\n    domain: AUTH0_DOMAIN,\n    clientId: options.clientID || options.clientId,\n    ...options,\n  };\n\n  let Auth0Instance;\n  if (auth0Options.management === true) {\n    auth0Options = _.omit(auth0Options, 'management');\n    const ManagementClient = require('auth0').ManagementClient;\n    Auth0Instance = new ManagementClient(auth0Options);\n  } else {\n    const AuthenticationClient = require('auth0').AuthenticationClient;\n    Auth0Instance = new AuthenticationClient(auth0Options);\n  }\n\n  return Auth0Instance;\n}\n\nfunction _parseAuth0Profile(rawProfile: any): User {\n  if (!rawProfile || typeof rawProfile !== 'object') {\n    return rawProfile;\n  }\n  return ((Object.keys(rawProfile).reduce((p, key) => {\n    p[_.camelCase(key)] = _parseAuth0Profile(rawProfile[key]);\n    return p;\n  }, {}): any): User);\n}\n\nfunction _prepareAuth0Profile(niceProfile: any): Object {\n  if (typeof niceProfile !== 'object') {\n    return niceProfile;\n  }\n\n  return ((Object.keys(niceProfile).reduce((p, key) => {\n    p[_.snakeCase(key)] = _prepareAuth0Profile(niceProfile[key]);\n    return p;\n  }, {}): any): User);\n}\n\ntype TokenInfo = {\n  access_token: string,\n  id_token: string,\n  refresh_token: string,\n};\n\nclass Deferred<X> {\n  promise: Promise<X>;\n  resolve: (...args: Array<*>) => void;\n  reject: (...args: Array<*>) => void;\n\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.reject = reject;\n      this.resolve = resolve;\n    });\n  }\n}\n\ntype ServerWithDestroy = {\n  destroy: Function,\n  listening: boolean,\n  on: Function,\n  close: Function,\n  listen: Function,\n};\n\nasync function _startLoginServerAsync(): Promise<{\n  server: ServerWithDestroy,\n  callbackURL: string,\n  getTokenInfoAsync: () => Promise<TokenInfo>,\n}> {\n  let dfd = new Deferred();\n\n  const server: ServerWithDestroy = ((http.createServer((req, res) => {\n    if (req.method === 'POST' && req.url === '/callback') {\n      let body = '';\n      req.on('data', function(data) {\n        body += data;\n      });\n      req.on('end', function() {\n        dfd.resolve(qs.parse(body));\n        res.writeHead(200, { 'Content-Type': 'text/html' });\n        res.end(\n          `\n          <html>\n          <head>\n            <script>\n              window.close();\n            </script>\n          </head>\n          <body>\n            Authenticated successfully! You can close this window.\n          </body>\n          </html>\n        `\n        );\n      });\n    } else {\n      res.writeHead(200, { 'Content-Type': 'text/html' });\n      res.end(\n        `\n        <html>\n        <head></head>\n        <body></body>\n        </html>\n      `\n      );\n    }\n  }): any): ServerWithDestroy);\n\n  server.on('clientError', (err, socket) => {\n    //eslint-disable-line\n    socket.end('HTTP/1.1 400 Bad Request\\r\\n\\r\\n');\n  });\n\n  let connections = {};\n\n  server.on('connection', function(conn) {\n    let key = conn.remoteAddress + ':' + conn.remotePort;\n    connections[key] = conn;\n    conn.on('close', function() {\n      delete connections[key];\n    });\n  });\n\n  server.destroy = function(cb) {\n    server.close(cb);\n    for (let key in connections) {\n      connections[key].destroy();\n    }\n  };\n\n  const port = await freeportAsync(11000);\n  try {\n    server.listen(port, '127.0.0.1');\n\n    return {\n      server,\n      callbackURL: `http://127.0.0.1:${port}/callback`,\n      getTokenInfoAsync: (): Promise<TokenInfo> => dfd.promise,\n    };\n  } catch (err) {\n    throw err;\n  }\n}\n"],"sourceRoot":"/xdl/src"}