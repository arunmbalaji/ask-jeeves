// Copyright 2015-present 650 Industries. All rights reserved.
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runShellAppModificationsAsync = exports.copyInitialShellAppFilesAsync = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

let regexFileAsync = (() => {
  var _ref = _asyncToGenerator(function* (regex, replace, filename) {
    let file = yield (_fsExtra || _load_fsExtra()).default.readFile(filename);
    let fileString = file.toString();
    yield (_fsExtra || _load_fsExtra()).default.writeFile(filename, fileString.replace(regex, replace));
  });

  return function regexFileAsync(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
})();

// Matches sed /d behavior


let deleteLinesInFileAsync = (() => {
  var _ref2 = _asyncToGenerator(function* (startRegex, endRegex, filename) {
    let file = yield (_fsExtra || _load_fsExtra()).default.readFile(filename);
    let fileString = file.toString();
    let lines = fileString.split(/\r?\n/);
    let filteredLines = [];
    let inDeleteRange = false;
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].match(startRegex)) {
        inDeleteRange = true;
      }

      if (!inDeleteRange) {
        filteredLines.push(lines[i]);
      }

      if (inDeleteRange && lines[i].match(endRegex)) {
        inDeleteRange = false;
      }
    }
    yield (_fsExtra || _load_fsExtra()).default.writeFile(filename, filteredLines.join('\n'));
  });

  return function deleteLinesInFileAsync(_x4, _x5, _x6) {
    return _ref2.apply(this, arguments);
  };
})();

let copyInitialShellAppFilesAsync = exports.copyInitialShellAppFilesAsync = (() => {
  var _ref4 = _asyncToGenerator(function* (androidSrcPath, shellPath, isDetached = false) {
    const _exponentDirectory = exponentDirectory();
    if (_exponentDirectory) {
      yield spawnAsync(`../../tools-public/generate-dynamic-macros-android.sh`, [], {
        pipeToLogger: true,
        loggerFields: { buildPhase: 'generating dynamic macros' },
        cwd: _path.default.join(_exponentDirectory, 'android', 'app'),
        env: _extends({}, process.env, {
          JSON_LOGS: '0'
        })
      }); // populate android template files now since we take out the prebuild step later on
    }

    const initialCopyLogger = (_Logger || _load_Logger()).default.withFields({ buildPhase: 'copying initial shell app files' });

    const copyToShellApp = (() => {
      var _ref5 = _asyncToGenerator(function* (fileName) {
        try {
          yield (_fsExtra || _load_fsExtra()).default.copy(_path.default.join(androidSrcPath, fileName), _path.default.join(shellPath, fileName));
        } catch (e) {
          // android.iml is only available locally, not on the builders, so don't crash when this happens
          initialCopyLogger.warn(`Warning: Could not copy ${fileName} to shell app directory.`);
        }
      });

      return function copyToShellApp(_x10) {
        return _ref5.apply(this, arguments);
      };
    })();

    if (!isDetached) {
      yield copyToShellApp('expoview');
      yield copyToShellApp('ReactCommon');
      yield copyToShellApp('ReactAndroid');
    }

    yield copyToShellApp('android.iml');
    yield copyToShellApp('app');
    yield copyToShellApp('build.gradle');
    yield copyToShellApp('gradle');
    yield copyToShellApp('gradle.properties');
    yield copyToShellApp('gradlew');
    yield copyToShellApp('settings.gradle');
    yield copyToShellApp('maven');
    yield copyToShellApp('debug.keystore');
    yield copyToShellApp('run.sh');
    yield copyToShellApp('detach-scripts');
  });

  return function copyInitialShellAppFilesAsync(_x8, _x9) {
    return _ref4.apply(this, arguments);
  };
})();

let copyIconsToResSubfolders = (() => {
  var _ref7 = _asyncToGenerator(function* (resDirPath, folderPrefix, fileName, iconUrl, isLocalUrl) {
    return Promise.all(imageKeys.map((() => {
      var _ref8 = _asyncToGenerator(function* (key) {
        try {
          const dirPath = _path.default.join(resDirPath, `${folderPrefix}-${key}`);
          (_fsExtra || _load_fsExtra()).default.accessSync(dirPath, (_fsExtra || _load_fsExtra()).default.constants.F_OK);
          if (isLocalUrl) {
            return (_fsExtra || _load_fsExtra()).default.copyFileSync(iconUrl, _path.default.join(dirPath, fileName));
          }
          return yield saveUrlToPathAsync(iconUrl, _path.default.join(dirPath, fileName));
        } catch (e) {
          // directory does not exist, so ignore
        }
      });

      return function (_x17) {
        return _ref8.apply(this, arguments);
      };
    })()));
  });

  return function copyIconsToResSubfolders(_x12, _x13, _x14, _x15, _x16) {
    return _ref7.apply(this, arguments);
  };
})();

let runShellAppModificationsAsync = exports.runShellAppModificationsAsync = (() => {
  var _ref9 = _asyncToGenerator(function* (context, isDetached = false) {
    const fnLogger = (_Logger || _load_Logger()).default.withFields({ buildPhase: 'running shell app modifications' });

    let shellPath = shellPathForContext(context);
    let url = context.published.url;
    let manifest = context.config; // manifest or app.json
    let releaseChannel = context.published.releaseChannel;

    if (!context.data.privateConfig) {
      fnLogger.warn('Warning: No config file specified.');
    }

    let fullManifestUrl = `${url.replace('exp://', 'https://')}/index.exp`;

    let versionCode = 1;
    let javaPackage = manifest.android.package;
    if (manifest.android.versionCode) {
      versionCode = manifest.android.versionCode;
    }

    if (!javaPackage) {
      throw new Error('Must specify androidPackage option (either from manifest or on command line).');
    }

    let name = manifest.name;
    let iconUrl = manifest.android && manifest.android.iconUrl ? manifest.android.iconUrl : manifest.iconUrl;
    let scheme = manifest.scheme || manifest.detach && manifest.detach.scheme;
    let bundleUrl = manifest.bundleUrl;
    let isFullManifest = !!bundleUrl;
    let notificationIconUrl = manifest.notification ? manifest.notification.iconUrl : null;
    let version = manifest.version ? manifest.version : '0.0.0';
    let backgroundImages = backgroundImagesForApp(shellPath, manifest, isDetached);
    let splashBackgroundColor = getSplashScreenBackgroundColor(manifest);
    let updatesDisabled = manifest.updates && manifest.updates.enabled === false;

    if (isDetached) {
      // manifest is actually just app.json in this case, so iconUrl fields don't exist
      iconUrl = manifest.android && manifest.android.icon ? manifest.android.icon : manifest.icon;
      notificationIconUrl = manifest.notification ? manifest.notification.icon : null;
    }

    // Clean build directories
    yield (_fsExtra || _load_fsExtra()).default.remove(_path.default.join(shellPath, 'app', 'build'));
    yield (_fsExtra || _load_fsExtra()).default.remove(_path.default.join(shellPath, 'ReactAndroid', 'build'));
    yield (_fsExtra || _load_fsExtra()).default.remove(_path.default.join(shellPath, 'expoview', 'build'));
    yield (_fsExtra || _load_fsExtra()).default.remove(_path.default.join(shellPath, 'app', 'src', 'androidTest'));

    if (isDetached) {
      let appBuildGradle = _path.default.join(shellPath, 'app', 'build.gradle');
      yield regexFileAsync(/\/\* UNCOMMENT WHEN DISTRIBUTING/g, '', appBuildGradle);
      yield regexFileAsync(/END UNCOMMENT WHEN DISTRIBUTING \*\//g, '', appBuildGradle);
      yield regexFileAsync(`compile project(path: ':expoview')`, '', appBuildGradle);

      // Don't need to compile expoview or ReactAndroid
      // react-native link looks for a \n so we need that. See https://github.com/facebook/react-native/blob/master/local-cli/link/android/patches/makeSettingsPatch.js
      yield (_fsExtra || _load_fsExtra()).default.writeFile(_path.default.join(shellPath, 'settings.gradle'), `include ':app'\n`);

      yield regexFileAsync('TEMPLATE_INITIAL_URL', url, _path.default.join(shellPath, 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'MainActivity.java'));
    }

    // Package
    yield regexFileAsync(`applicationId 'host.exp.exponent'`, `applicationId '${javaPackage}'`, _path.default.join(shellPath, 'app', 'build.gradle'));
    yield regexFileAsync(`android:name="host.exp.exponent"`, `android:name="${javaPackage}"`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));

    // Versions
    let buildGradleFile = yield (_fsExtra || _load_fsExtra()).default.readFileSync(_path.default.join(shellPath, 'app', 'build.gradle'), 'utf8');
    let androidVersion = buildGradleFile.match(/versionName '(\S+)'/)[1];
    yield regexFileAsync('VERSION_NAME = null', `VERSION_NAME = "${androidVersion}"`, _path.default.join(shellPath, 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java'));
    yield deleteLinesInFileAsync(`BEGIN\ VERSIONS`, `END\ VERSIONS`, _path.default.join(shellPath, 'app', 'build.gradle'));
    yield regexFileAsync('// ADD VERSIONS HERE', `versionCode ${versionCode}
    versionName '${version}'`, _path.default.join(shellPath, 'app', 'build.gradle'));

    // Remove Exponent build script
    if (!isDetached) {
      yield regexFileAsync(`preBuild.dependsOn generateDynamicMacros`, ``, _path.default.join(shellPath, 'expoview', 'build.gradle'));
    }

    // change javaMaxHeapSize
    yield regexFileAsync(`javaMaxHeapSize "8g"`, `javaMaxHeapSize "6g"`, _path.default.join(shellPath, 'app', 'build.gradle'));

    // Push notifications
    yield regexFileAsync('"package_name": "host.exp.exponent"', `"package_name": "${javaPackage}"`, _path.default.join(shellPath, 'app', 'google-services.json')); // TODO: actually use the correct file

    // TODO: probably don't need this in both places
    yield regexFileAsync(/host\.exp\.exponent\.permission\.C2D_MESSAGE/g, `${javaPackage}.permission.C2D_MESSAGE`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));
    if (!isDetached) {
      yield regexFileAsync(/host\.exp\.exponent\.permission\.C2D_MESSAGE/g, `${javaPackage}.permission.C2D_MESSAGE`, _path.default.join(shellPath, 'expoview', 'src', 'main', 'AndroidManifest.xml'));
    }

    // Set INITIAL_URL, SHELL_APP_SCHEME and SHOW_LOADING_VIEW
    yield regexFileAsync('INITIAL_URL = null', `INITIAL_URL = "${url}"`, _path.default.join(shellPath, 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java'));
    if (scheme) {
      yield regexFileAsync('SHELL_APP_SCHEME = null', `SHELL_APP_SCHEME = "${scheme}"`, _path.default.join(shellPath, 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java'));
    }
    if (shouldShowLoadingView(manifest)) {
      yield regexFileAsync('SHOW_LOADING_VIEW_IN_SHELL_APP = false', 'SHOW_LOADING_VIEW_IN_SHELL_APP = true', _path.default.join(shellPath, 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java'));
    }
    if (isDetached) {
      yield regexFileAsync('IS_DETACHED = false', `IS_DETACHED = true`, _path.default.join(shellPath, 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java'));
    }
    if (updatesDisabled) {
      yield regexFileAsync('ARE_REMOTE_UPDATES_ENABLED = true', 'ARE_REMOTE_UPDATES_ENABLED = false', _path.default.join(shellPath, 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java'));
    }

    // App name
    yield regexFileAsync('"app_name">Expo', `"app_name">${xmlWeirdAndroidEscape(name)}`, _path.default.join(shellPath, 'app', 'src', 'main', 'res', 'values', 'strings.xml'));

    // Splash Screen background color
    yield regexFileAsync('"splashBackground">#FFFFFF', `"splashBackground">${splashBackgroundColor}`, _path.default.join(shellPath, 'app', 'src', 'main', 'res', 'values', 'colors.xml'));

    // show only background color if LoadingView will appear
    if (shouldShowLoadingView(manifest)) {
      yield regexFileAsync(/<item>.*<\/item>/, '', _path.default.join(shellPath, 'app', 'src', 'main', 'res', 'drawable', 'splash_background.xml'));
    }

    // Remove exp:// scheme from LauncherActivity
    yield deleteLinesInFileAsync(`START\ LAUNCHER\ INTENT\ FILTERS`, `END\ LAUNCHER\ INTENT\ FILTERS`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));

    // Remove LAUNCHER category from HomeActivity
    yield deleteLinesInFileAsync(`START\ HOME\ INTENT\ FILTERS`, `END\ HOME\ INTENT\ FILTERS`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));

    if (isDetached) {
      // Add LAUNCHER category to MainActivity
      yield regexFileAsync('<!-- ADD DETACH INTENT FILTERS HERE -->', `<intent-filter>
        <action android:name="android.intent.action.MAIN"/>

        <category android:name="android.intent.category.LAUNCHER"/>
      </intent-filter>`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));
    } else {
      // Add LAUNCHER category to ShellAppActivity
      yield regexFileAsync('<!-- ADD SHELL INTENT FILTERS HERE -->', `<intent-filter>
        <action android:name="android.intent.action.MAIN"/>

        <category android:name="android.intent.category.LAUNCHER"/>
      </intent-filter>`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));
    }

    // Add shell app scheme
    if (scheme) {
      yield regexFileAsync('<!-- ADD SHELL SCHEME HERE -->', `<intent-filter>
        <data android:scheme="${scheme}"/>

        <action android:name="android.intent.action.VIEW"/>

        <category android:name="android.intent.category.DEFAULT"/>
        <category android:name="android.intent.category.BROWSABLE"/>
      </intent-filter>`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));
    }

    // Add permissions
    if (manifest.android && manifest.android.permissions) {
      const content = yield (_fsExtra || _load_fsExtra()).default.readFileSync(_path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'), 'utf-8');

      // Get the list of optional permissions form manifest
      const permissions = content.replace(/(([\s\S]*<!-- BEGIN OPTIONAL PERMISSIONS -->)|(<!-- END OPTIONAL PERMISSIONS -->[\s\S]*))/g, '').match(/android:name=".+"/g).map(function (p) {
        return p.replace(/(android:name=|")/g, '');
      });

      const whitelist = [];

      manifest.android.permissions.forEach(function (s) {
        if (s.includes('.')) {
          whitelist.push(s);
        } else {
          permissions.forEach(function (identifier) {
            if (identifier.split('.').pop() === s) {
              whitelist.push(identifier);
            }
          });
        }
      });

      // Permissions we need to remove from the generated manifest
      const blacklist = ['android.permission.ACCESS_COARSE_LOCATION', 'android.permission.ACCESS_FINE_LOCATION', 'android.permission.CAMERA', 'android.permission.MANAGE_DOCUMENTS', 'android.permission.READ_CONTACTS', 'android.permission.READ_CALENDAR', 'android.permission.WRITE_CALENDAR', 'android.permission.READ_EXTERNAL_STORAGE', 'android.permission.READ_INTERNAL_STORAGE', 'android.permission.READ_PHONE_STATE', 'android.permission.RECORD_AUDIO', 'android.permission.USE_FINGERPRINT', 'android.permission.VIBRATE', 'android.permission.WRITE_EXTERNAL_STORAGE', 'com.anddoes.launcher.permission.UPDATE_COUNT', 'com.android.launcher.permission.INSTALL_SHORTCUT', 'com.google.android.gms.permission.ACTIVITY_RECOGNITION', 'com.google.android.providers.gsf.permission.READ_GSERVICES', 'com.htc.launcher.permission.READ_SETTINGS', 'com.htc.launcher.permission.UPDATE_SHORTCUT', 'com.majeur.launcher.permission.UPDATE_BADGE', 'com.sec.android.provider.badge.permission.READ', 'com.sec.android.provider.badge.permission.WRITE', 'com.sonyericsson.home.permission.BROADCAST_BADGE'].filter(function (p) {
        return !whitelist.includes(p);
      });

      yield deleteLinesInFileAsync(`BEGIN\ OPTIONAL\ PERMISSIONS`, `END\ OPTIONAL\ PERMISSIONS`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));

      yield regexFileAsync('<!-- ADD PERMISSIONS HERE -->', `
      ${whitelist.map(function (p) {
        return `<uses-permission android:name="${p}" />`;
      }).join('\n')}
      ${blacklist.map(function (p) {
        return `<uses-permission android:name="${p}" tools:node="remove" />`;
      }).join('\n')}
      `, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));
    }

    // OAuth redirect scheme
    yield regexFileAsync('<data android:scheme="host.exp.exponent" android:path="oauthredirect"/>', `<data android:scheme="${javaPackage}" android:path="oauthredirect"/>`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));

    // Embed manifest and bundle
    if (isFullManifest) {
      yield (_fsExtra || _load_fsExtra()).default.writeFileSync(_path.default.join(shellPath, 'app', 'src', 'main', 'assets', 'shell-app-manifest.json'), JSON.stringify(manifest));
      yield saveUrlToPathAsync(bundleUrl, _path.default.join(shellPath, 'app', 'src', 'main', 'assets', 'shell-app.bundle'));

      yield regexFileAsync('// START EMBEDDED RESPONSES', `
      // START EMBEDDED RESPONSES
      embeddedResponses.add(new Constants.EmbeddedResponse("${fullManifestUrl}", "assets://shell-app-manifest.json", "application/json"));
      embeddedResponses.add(new Constants.EmbeddedResponse("${bundleUrl}", "assets://shell-app.bundle", "application/javascript"));`, _path.default.join(shellPath, 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java'));
    }

    yield regexFileAsync('RELEASE_CHANNEL = "default"', `RELEASE_CHANNEL = "${releaseChannel}"`, _path.default.join(shellPath, 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java'));

    // Icon
    if (iconUrl) {
      (yield (0, (_globby || _load_globby()).default)(['**/ic_launcher.png'], {
        cwd: _path.default.join(shellPath, 'app', 'src', 'main', 'res'),
        absolute: true
      })).forEach(function (filePath) {
        (_fsExtra || _load_fsExtra()).default.removeSync(filePath);
      });

      yield copyIconsToResSubfolders(_path.default.join(shellPath, 'app', 'src', 'main', 'res'), 'mipmap', 'ic_launcher.png', iconUrl, isDetached);
    }

    if (notificationIconUrl) {
      (yield (0, (_globby || _load_globby()).default)(['**/shell_notification_icon.png'], {
        cwd: _path.default.join(shellPath, 'app', 'src', 'main', 'res'),
        absolute: true
      })).forEach(function (filePath) {
        (_fsExtra || _load_fsExtra()).default.removeSync(filePath);
      });

      yield copyIconsToResSubfolders(_path.default.join(shellPath, 'app', 'src', 'main', 'res'), 'drawable', 'shell_notification_icon.png', notificationIconUrl, isDetached);
    }

    // Splash Background
    if (backgroundImages && backgroundImages.length > 0) {
      // Delete the placeholder images
      (yield (0, (_globby || _load_globby()).default)(['**/shell_launch_background_image.png'], {
        cwd: _path.default.join(shellPath, 'app', 'src', 'main', 'res'),
        absolute: true
      })).forEach(function (filePath) {
        (_fsExtra || _load_fsExtra()).default.removeSync(filePath);
      });

      (_lodash || _load_lodash()).default.forEach(backgroundImages, (() => {
        var _ref10 = _asyncToGenerator(function* (image) {
          if (isDetached) {
            // local file so just copy it
            (_fsExtra || _load_fsExtra()).default.copyFileSync(image.url, image.path);
          } else {
            yield saveUrlToPathAsync(image.url, image.path);
          }
        });

        return function (_x19) {
          return _ref10.apply(this, arguments);
        };
      })());
    }

    if (manifest.bundledAssets) {
      yield downloadAssetsAsync(manifest.bundledAssets, `${shellPath}/app/src/main/assets`);
    }

    let certificateHash = '';
    let googleAndroidApiKey = '';
    let privateConfig = context.data.privateConfig;
    if (privateConfig) {
      let branch = privateConfig.branch;
      let fabric = privateConfig.fabric;
      let googleMaps = privateConfig.googleMaps;
      let googleSignIn = privateConfig.googleSignIn;

      // Branch
      if (branch) {
        yield regexFileAsync('<!-- ADD BRANCH CONFIG HERE -->', `<meta-data
      android:name="io.branch.sdk.BranchKey"
      android:value="${branch.apiKey}"/>`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));
      }

      // Fabric
      if (fabric) {
        yield (_fsExtra || _load_fsExtra()).default.remove(_path.default.join(shellPath, 'app', 'fabric.properties'));
        yield (_fsExtra || _load_fsExtra()).default.writeFileSync(_path.default.join(shellPath, 'app', 'fabric.properties'), `apiSecret=${fabric.buildSecret}\n`);

        yield deleteLinesInFileAsync(`BEGIN\ FABRIC\ CONFIG`, `END\ FABRIC\ CONFIG`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));
        yield regexFileAsync('<!-- ADD FABRIC CONFIG HERE -->', `<meta-data
      android:name="io.fabric.ApiKey"
      android:value="${fabric.apiKey}"/>`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));
      }

      // Google Maps
      if (googleMaps) {
        yield deleteLinesInFileAsync(`BEGIN\ GOOGLE\ MAPS\ CONFIG`, `END\ GOOGLE\ MAPS\ CONFIG`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));
        yield regexFileAsync('<!-- ADD GOOGLE MAPS CONFIG HERE -->', `<meta-data
      android:name="com.google.android.geo.API_KEY"
      android:value="${googleMaps.apiKey}"/>`, _path.default.join(shellPath, 'app', 'src', 'main', 'AndroidManifest.xml'));
      }

      // Google Login
      if (googleSignIn) {
        certificateHash = googleSignIn.certificateHash;
        googleAndroidApiKey = googleSignIn.apiKey;
      }
    }

    // Google sign in
    yield regexFileAsync(/"current_key": "(.*?)"/, `"current_key": "${googleAndroidApiKey}"`, _path.default.join(shellPath, 'app', 'google-services.json'));
    yield regexFileAsync(/"certificate_hash": "(.*?)"/, `"certificate_hash": "${certificateHash}"`, _path.default.join(shellPath, 'app', 'google-services.json'));
  });

  return function runShellAppModificationsAsync(_x18) {
    return _ref9.apply(this, arguments);
  };
})();

let buildShellAppAsync = (() => {
  var _ref11 = _asyncToGenerator(function* (context) {
    let shellPath = shellPathForContext(context);

    if (context.build.android) {
      let androidBuildConfiguration = context.build.android;

      try {
        yield (_fsExtra || _load_fsExtra()).default.remove(`shell-unaligned.apk`);
        yield (_fsExtra || _load_fsExtra()).default.remove(`shell.apk`);
      } catch (e) {}
      const gradleArgs = [`assembleProdRelease`];
      if (process.env.GRADLE_DAEMON_DISABLED) {
        gradleArgs.unshift('--no-daemon');
      }
      yield spawnAsyncThrowError(`./gradlew`, gradleArgs, {
        pipeToLogger: true,
        loggerFields: { buildPhase: 'running gradle' },
        cwd: shellPath
      });
      yield (_fsExtra || _load_fsExtra()).default.copy(_path.default.join(shellPath, 'app', 'build', 'outputs', 'apk', 'app-prod-release-unsigned.apk'), `shell-unaligned.apk`);
      yield spawnAsync(`jarsigner`, ['-verbose', '-sigalg', 'SHA1withRSA', '-digestalg', 'SHA1', '-storepass', androidBuildConfiguration.keystorePassword, '-keypass', androidBuildConfiguration.keyPassword, '-keystore', androidBuildConfiguration.keystore, 'shell-unaligned.apk', androidBuildConfiguration.keyAlias], {
        pipeToLogger: true,
        loggerFields: { buildPhase: 'signing created apk' }
      });
      yield spawnAsync(`zipalign`, ['-v', '4', 'shell-unaligned.apk', 'shell.apk'], {
        pipeToLogger: true,
        loggerFields: { buildPhase: 'verifying apk alignment' }
      });
      try {
        yield (_fsExtra || _load_fsExtra()).default.remove('shell-unaligned.apk');
      } catch (e) {}
      yield spawnAsync(`jarsigner`, ['-verify', '-verbose', '-certs', '-keystore', androidBuildConfiguration.keystore, 'shell.apk'], {
        pipeToLogger: true,
        loggerFields: { buildPhase: 'verifying apk' }
      });
      yield (_fsExtra || _load_fsExtra()).default.copy('shell.apk', androidBuildConfiguration.outputFile || '/tmp/shell-signed.apk');
    } else {
      try {
        yield (_fsExtra || _load_fsExtra()).default.remove('shell-debug.apk');
      } catch (e) {}
      yield spawnAsyncThrowError(`./gradlew`, ['assembleDevRemoteKernelDebug'], {
        pipeToLogger: true,
        loggerFields: { buildPhase: 'running gradle' },
        cwd: shellPath
      });
      yield (_fsExtra || _load_fsExtra()).default.copy(_path.default.join(shellPath, 'app', 'build', 'outputs', 'apk', 'app-devRemoteKernel-debug.apk'), `/tmp/shell-debug.apk`);
    }
  });

  return function buildShellAppAsync(_x20) {
    return _ref11.apply(this, arguments);
  };
})();

let downloadAssetsAsync = (() => {
  var _ref12 = _asyncToGenerator(function* (assets, dest) {
    // Compat with exp 46.x.x, can remove when this version is phasing out.
    if (typeof assets[0] === 'object') {
      assets = assets.reduce(function (res, cur) {
        return res.concat(cur.fileHashes.map(function (h) {
          return 'asset_' + h + (cur.type ? '.' + cur.type : '');
        }));
      }, []);
    }

    yield (_fsExtra || _load_fsExtra()).default.ensureDir(dest);
    const batches = (_lodash || _load_lodash()).default.chunk(assets, 5);
    for (const batch of batches) {
      yield Promise.all(batch.map((() => {
        var _ref13 = _asyncToGenerator(function* (asset) {
          const extensionIndex = asset.lastIndexOf('.');
          const prefixLength = 'asset_'.length;
          const hash = extensionIndex >= 0 ? asset.substring(prefixLength, extensionIndex) : asset.substring(prefixLength);
          yield saveUrlToPathAsync('https://d1wp6m56sqw74a.cloudfront.net/~assets/' + hash, _path.default.join(dest, asset));
        });

        return function (_x23) {
          return _ref13.apply(this, arguments);
        };
      })()));
    }
  });

  return function downloadAssetsAsync(_x21, _x22) {
    return _ref12.apply(this, arguments);
  };
})();

var _fsExtra;

function _load_fsExtra() {
  return _fsExtra = _interopRequireDefault(require('fs-extra'));
}

var _path = _interopRequireDefault(require('path'));

var _jsonFile;

function _load_jsonFile() {
  return _jsonFile = _interopRequireDefault(require('@expo/json-file'));
}

var _replaceString;

function _load_replaceString() {
  return _replaceString = _interopRequireDefault(require('replace-string'));
}

var _lodash;

function _load_lodash() {
  return _lodash = _interopRequireDefault(require('lodash'));
}

var _globby;

function _load_globby() {
  return _globby = _interopRequireDefault(require('globby'));
}

var _ExponentTools;

function _load_ExponentTools() {
  return _ExponentTools = _interopRequireWildcard(require('./ExponentTools'));
}

var _StandaloneBuildFlags;

function _load_StandaloneBuildFlags() {
  return _StandaloneBuildFlags = _interopRequireDefault(require('./StandaloneBuildFlags'));
}

var _StandaloneContext;

function _load_StandaloneContext() {
  return _StandaloneContext = _interopRequireDefault(require('./StandaloneContext'));
}

var _Logger;

function _load_Logger() {
  return _Logger = _interopRequireDefault(require('./Logger'));
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const { getManifestAsync, saveUrlToPathAsync, spawnAsyncThrowError, spawnAsync } = _ExponentTools || _load_ExponentTools();

const imageKeys = ['ldpi', 'mdpi', 'hdpi', 'xhdpi', 'xxhdpi', 'xxxhdpi'];

// Do not call this from anything used by detach
function exponentDirectory() {
  if (process.env.TURTLE_WORKING_DIR_PATH) {
    return process.env.TURTLE_WORKING_DIR_PATH;
  } else if (process.env.EXPO_UNIVERSE_DIR) {
    return _path.default.join(process.env.EXPO_UNIVERSE_DIR, 'exponent');
  } else {
    return null;
  }
}

function xmlWeirdAndroidEscape(original) {
  let noAmps = (0, (_replaceString || _load_replaceString()).default)(original, '&', '&amp;');
  let noLt = (0, (_replaceString || _load_replaceString()).default)(noAmps, '<', '&lt;');
  let noGt = (0, (_replaceString || _load_replaceString()).default)(noLt, '>', '&gt;');
  let noApos = (0, (_replaceString || _load_replaceString()).default)(noGt, '"', '\\"');
  return (0, (_replaceString || _load_replaceString()).default)(noApos, "'", "\\'");
}

exports.updateAndroidShellAppAsync = (() => {
  var _ref3 = _asyncToGenerator(function* (args) {
    let {
      url,
      sdkVersion,
      androidPackage,
      privateConfigFile,
      keystore,
      alias,
      keystorePassword,
      keyPassword,
      releaseChannel,
      outputFile
    } = args;

    releaseChannel = releaseChannel ? releaseChannel : 'default';
    let manifest = yield getManifestAsync(url, {
      'Exponent-SDK-Version': sdkVersion,
      'Exponent-Platform': 'android',
      'Expo-Release-Channel': releaseChannel
    });

    let fullManifestUrl = `${url.replace('exp://', 'https://')}/index.exp`;
    let bundleUrl = manifest.bundleUrl;

    let shellPath = _path.default.join(exponentDirectory(), 'android-shell-app');

    yield (_fsExtra || _load_fsExtra()).default.remove(_path.default.join(shellPath, 'app', 'src', 'main', 'assets', 'shell-app-manifest.json'));
    yield (_fsExtra || _load_fsExtra()).default.writeFileSync(_path.default.join(shellPath, 'app', 'src', 'main', 'assets', 'shell-app-manifest.json'), JSON.stringify(manifest));
    yield (_fsExtra || _load_fsExtra()).default.remove(_path.default.join(shellPath, 'app', 'src', 'main', 'assets', 'shell-app.bundle'));
    yield saveUrlToPathAsync(bundleUrl, _path.default.join(shellPath, 'app', 'src', 'main', 'assets', 'shell-app.bundle'));

    yield deleteLinesInFileAsync(`START\ EMBEDDED\ RESPONSES`, `END\ EMBEDDED\ RESPONSES`, _path.default.join(shellPath, 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java'));

    yield regexFileAsync('// ADD EMBEDDED RESPONSES HERE', `
    // ADD EMBEDDED RESPONSES HERE
    // START EMBEDDED RESPONSES
    embeddedResponses.add(new Constants.EmbeddedResponse("${fullManifestUrl}", "assets://shell-app-manifest.json", "application/json"));
    embeddedResponses.add(new Constants.EmbeddedResponse("${bundleUrl}", "assets://shell-app.bundle", "application/javascript"));
    // END EMBEDDED RESPONSES`, _path.default.join(shellPath, 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java'));

    yield regexFileAsync('RELEASE_CHANNEL = "default"', `RELEASE_CHANNEL = "${releaseChannel}"`, _path.default.join(shellPath, 'app', 'src', 'main', 'java', 'host', 'exp', 'exponent', 'generated', 'AppConstants.java'));
  });

  function updateAndroidShellAppAsync(_x7) {
    return _ref3.apply(this, arguments);
  }

  return updateAndroidShellAppAsync;
})();

function getRemoteOrLocalUrl(manifest, key, isDetached) {
  // in detached apps, `manifest` is actually just app.json, so there are no remote url fields
  // we should return a local url starting with file:// instead
  if (isDetached) {
    return (_lodash || _load_lodash()).default.get(manifest, key);
  }
  return (_lodash || _load_lodash()).default.get(manifest, `${key}Url`);
}

function backgroundImagesForApp(shellPath, manifest, isDetached) {
  // returns an array like:
  // [
  //   {url: 'urlToDownload', path: 'pathToSaveTo'},
  //   {url: 'anotherURlToDownload', path: 'anotherPathToSaveTo'},
  // ]
  let basePath = _path.default.join(shellPath, 'app', 'src', 'main', 'res');
  if ((_lodash || _load_lodash()).default.get(manifest, 'android.splash')) {
    var splash = (_lodash || _load_lodash()).default.get(manifest, 'android.splash');
    return (_lodash || _load_lodash()).default.reduce(imageKeys, function (acc, imageKey) {
      let url = getRemoteOrLocalUrl(splash, imageKey, isDetached);
      if (url) {
        acc.push({
          url,
          path: _path.default.join(basePath, `drawable-${imageKey}`, 'shell_launch_background_image.png')
        });
      }

      return acc;
    }, []);
  }

  let url = getRemoteOrLocalUrl(manifest, 'splash.image', isDetached);
  if (url) {
    return [{
      url,
      path: _path.default.join(basePath, 'drawable-xxxhdpi', 'shell_launch_background_image.png')
    }];
  }

  return [];
}

function getSplashScreenBackgroundColor(manifest) {
  let backgroundColor;
  if (manifest.android && manifest.android.splash && manifest.android.splash.backgroundColor) {
    backgroundColor = manifest.android.splash.backgroundColor;
  } else if (manifest.splash && manifest.splash.backgroundColor) {
    backgroundColor = manifest.splash.backgroundColor;
  }

  // Default to white
  if (!backgroundColor) {
    backgroundColor = '#FFFFFF';
  }
  return backgroundColor;
}

/*
  if resizeMode is 'cover' we should show LoadingView:
  using an ImageView, unlike having a BitmapDrawable
  provides a fullscreen image without distortions
*/
function shouldShowLoadingView(manifest) {
  return manifest.android && manifest.android.splash && manifest.android.splash.resizeMode && manifest.android.splash.resizeMode === 'cover' || manifest.splash && manifest.splash.resizeMode && manifest.splash.resizeMode === 'cover';
}

exports.createAndroidShellAppAsync = (() => {
  var _ref6 = _asyncToGenerator(function* (args) {
    let {
      url,
      sdkVersion,
      releaseChannel,
      privateConfigFile,
      configuration,
      keystore,
      alias,
      keystorePassword,
      keyPassword,
      outputFile
    } = args;

    let androidSrcPath = _path.default.join(exponentDirectory(), 'android');
    let shellPath = _path.default.join(exponentDirectory(), 'android-shell-app');

    yield (_fsExtra || _load_fsExtra()).default.remove(shellPath);
    yield (_fsExtra || _load_fsExtra()).default.ensureDir(shellPath);

    releaseChannel = releaseChannel ? releaseChannel : 'default';
    let manifest = yield getManifestAsync(url, {
      'Exponent-SDK-Version': sdkVersion,
      'Exponent-Platform': 'android',
      'Expo-Release-Channel': releaseChannel
    });
    configuration = configuration ? configuration : 'Release';

    let privateConfig;
    if (privateConfigFile) {
      let privateConfigContents = yield (_fsExtra || _load_fsExtra()).default.readFile(privateConfigFile, 'utf8');
      privateConfig = JSON.parse(privateConfigContents);
    }

    let androidBuildConfiguration;
    if (keystore && alias && keystorePassword && keyPassword) {
      androidBuildConfiguration = {
        keystore,
        keystorePassword,
        keyAlias: alias,
        keyPassword,
        outputFile
      };
    }

    let buildFlags = (_StandaloneBuildFlags || _load_StandaloneBuildFlags()).default.createAndroid(configuration, androidBuildConfiguration);
    let context = (_StandaloneContext || _load_StandaloneContext()).default.createServiceContext(androidSrcPath, null, manifest, privateConfig,
    /* testEnvironment */'none', buildFlags, url, releaseChannel);

    yield copyInitialShellAppFilesAsync(androidSrcPath, shellPath);
    yield runShellAppModificationsAsync(context);

    if (!args.skipBuild) {
      yield buildShellAppAsync(context);
    }
  });

  function createAndroidShellAppAsync(_x11) {
    return _ref6.apply(this, arguments);
  }

  return createAndroidShellAppAsync;
})();

function shellPathForContext(context) {
  if (context.type === 'user') {
    return _path.default.join(context.data.projectPath, 'android');
  } else {
    return _path.default.join(exponentDirectory(), 'android-shell-app');
  }
}
//# sourceMappingURL=../__sourcemaps__/detach/AndroidShellApp.js.map
