// Copyright 2015-present 650 Industries. All rights reserved.

'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.configureBundleAsync = exports.buildAsync = undefined;

/**
 *  Build the iOS workspace at the given path.
 *  @return the path to the resulting build artifact
 */
let _buildAsync = (() => {
  var _ref = _asyncToGenerator(function* (workspacePath, configuration, type, derivedDataPath, verbose) {
    let buildCmd, pathToArtifact;
    const projectName = 'Exponent';
    if (type === 'simulator') {
      buildCmd = `xcodebuild -workspace ${projectName}.xcworkspace -scheme ${projectName} -sdk iphonesimulator -configuration ${configuration} -derivedDataPath ${derivedDataPath} CODE_SIGN_IDENTITY="" CODE_SIGNING_REQUIRED=NO ARCHS="i386 x86_64" ONLY_ACTIVE_ARCH=NO | xcpretty`;
      pathToArtifact = _path.default.join(derivedDataPath, 'Build', 'Products', `${configuration}-iphonesimulator`, `${projectName}.app`);
    } else if (type === 'archive') {
      buildCmd = `xcodebuild -workspace ${projectName}.xcworkspace -scheme ${projectName} -sdk iphoneos -destination generic/platform=iOS -configuration ${configuration} archive -derivedDataPath ${derivedDataPath} -archivePath ${derivedDataPath}/${projectName}.xcarchive CODE_SIGN_IDENTITY="" CODE_SIGNING_REQUIRED=NO | xcpretty`;
      pathToArtifact = _path.default.join(derivedDataPath, `${projectName}.xcarchive`);
    } else {
      throw new Error(`Unsupported build type: ${type}`);
    }

    (_Logger || _load_Logger()).default.info(`Building iOS workspace at ${workspacePath} with derived data path ${derivedDataPath}:\n`);
    (_Logger || _load_Logger()).default.info(buildCmd);
    if (!verbose) {
      (_Logger || _load_Logger()).default.info('\nxcodebuild is running. Logging errors only. To see full output, use --verbose 1...');
    }
    yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)(buildCmd, null, {
      // only stderr
      stdio: verbose ? 'inherit' : ['ignore', 'ignore', 'inherit'],
      cwd: workspacePath,
      shell: true
    });
    return _path.default.resolve(workspacePath, pathToArtifact);
  });

  return function _buildAsync(_x, _x2, _x3, _x4, _x5) {
    return _ref.apply(this, arguments);
  };
})();

let _configureExpoClientBundleAsync = (() => {
  var _ref2 = _asyncToGenerator(function* (pathToArchive, bundleId, appleTeamIdentifierPrefix) {
    // configure bundle id in Info.plist
    yield (_IosPlist || _load_IosPlist()).modifyAsync(pathToArchive, 'Info', function (infoPlist) {
      infoPlist.CFBundleIdentifier = bundleId;
      return infoPlist;
    });

    // replace all instances of expo entitlement with custom bundle id entitlement
    let entitlementsFile = _path.default.join(pathToArchive, 'Exponent.entitlements');
    if ((_fsExtra || _load_fsExtra()).default.existsSync(entitlementsFile)) {
      let entitlementsFileContents = yield (_fsExtra || _load_fsExtra()).default.readFile(entitlementsFile, 'utf8');
      entitlementsFileContents = entitlementsFileContents.replace(/host\.exp\.Exponent/g, bundleId);
      entitlementsFileContents = entitlementsFileContents.replace(/\$\(CFBundleIdentifier\)/g, bundleId);
      if (appleTeamIdentifierPrefix) {
        entitlementsFileContents = entitlementsFileContents.replace(/\$\(TeamIdentifierPrefix\)/g, appleTeamIdentifierPrefix);
      }
      yield (_fsExtra || _load_fsExtra()).default.writeFile(entitlementsFile, entitlementsFileContents);
    }
  });

  return function _configureExpoClientBundleAsync(_x6, _x7, _x8) {
    return _ref2.apply(this, arguments);
  };
})();

let _buildAndCopyClientArtifactAsync = (() => {
  var _ref3 = _asyncToGenerator(function* (buildType, buildConfiguration, verbose) {
    const clientWorkspacePath = _path.default.join('..', 'ios');
    let buildPath = _path.default.join('..', 'client-builds');
    let derivedDataPath = _path.default.join(buildPath, 'derived-data', buildType);

    const pathToArtifact = yield _buildAsync(clientWorkspacePath, buildConfiguration, buildType, _path.default.relative(clientWorkspacePath, derivedDataPath), verbose);
    const artifactDestPath = _path.default.join(buildPath, 'artifacts', buildType, buildConfiguration);
    (_Logger || _load_Logger()).default.info(`\nFinished building, copying artifact to ${_path.default.resolve(artifactDestPath)}...`);
    if ((_fsExtra || _load_fsExtra()).default.existsSync(artifactDestPath)) {
      yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('/bin/rm', ['-rf', artifactDestPath]);
    }
    (_Logger || _load_Logger()).default.info(`mkdir -p ${artifactDestPath}`);
    yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('/bin/mkdir', ['-p', artifactDestPath]);
    (_Logger || _load_Logger()).default.info(`cp -R ${pathToArtifact} ${artifactDestPath}`);
    yield (0, (_ExponentTools || _load_ExponentTools()).spawnAsyncThrowError)('/bin/cp', ['-R', pathToArtifact, artifactDestPath]);
  });

  return function _buildAndCopyClientArtifactAsync(_x9, _x10, _x11) {
    return _ref3.apply(this, arguments);
  };
})();

let buildAsync = (() => {
  var _ref4 = _asyncToGenerator(function* (buildType, buildConfiguration, verbose) {
    if (!(buildType === 'simulator' || buildType == 'archive')) {
      throw new Error(`Unsupported build type: ${buildType}`);
    }
    if (!(buildConfiguration === 'debug' || buildConfiguration == 'release')) {
      throw new Error(`Unsupported build configuration: ${buildConfiguration}`);
    }
    return _buildAndCopyClientArtifactAsync(buildType, buildConfiguration, verbose);
  });

  return function buildAsync(_x12, _x13, _x14) {
    return _ref4.apply(this, arguments);
  };
})();

let configureBundleAsync = (() => {
  var _ref5 = _asyncToGenerator(function* (pathToArchive, bundleId, appleTeamId) {
    if (!pathToArchive) {
      throw new Error('Must specify path to Expo Client archive to configure.');
    }
    if (!bundleId) {
      throw new Error('Must specify a bundle identifier to write.');
    }
    if (!appleTeamId) {
      (_Logger || _load_Logger()).default.warn('No apple team id was specified. This may lead to unexpected behavior with the resulting Entitlements.');
    }
    return _configureExpoClientBundleAsync(pathToArchive, bundleId, appleTeamId);
  });

  return function configureBundleAsync(_x15, _x16, _x17) {
    return _ref5.apply(this, arguments);
  };
})();

var _fsExtra;

function _load_fsExtra() {
  return _fsExtra = _interopRequireDefault(require('fs-extra'));
}

var _path = _interopRequireDefault(require('path'));

var _ExponentTools;

function _load_ExponentTools() {
  return _ExponentTools = require('../detach/ExponentTools');
}

var _IosPlist;

function _load_IosPlist() {
  return _IosPlist = _interopRequireWildcard(require('../detach/IosPlist'));
}

var _Logger;

function _load_Logger() {
  return _Logger = _interopRequireDefault(require('../detach/Logger'));
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

exports.buildAsync = buildAsync;
exports.configureBundleAsync = configureBundleAsync;
//# sourceMappingURL=../__sourcemaps__/client/IosClient.js.map
